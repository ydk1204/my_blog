---
title: 백준 2579번 계단오르기 JavaScript, NodeJS
date: 2023-07-28
description: 백준 2579번 계단오르기 JavaScript, NodeJS 풀이방법, dynamic programming, DP, 동적 알고리즘
img: /postImg/algorithm/stepBystep.png
tag: study
note: algorithm
copyright: https://www.acmicpc.net/problem/2579
---

## 백준 2579번 계단오르기

문제 링크 ➡ [2579번: 계단오르기][백준]

---

## 믄제

문제 :

1. 계단이 있다.
2. 계단 맨 아래부터 시작하여 계단 꼭대기(마지막 계단)까지 도달해야 한다.
3. 각 계단마다 점수가 있고, 계단을 밟으면 그 계단에 배당되어 있는 점수를 얻는다.
4. 마지막 계단까지 도달했을 때 가장 높은 점수를 얻기 위한 방법을 제시하라

규칙 :

1. 계단은 한번에 한 계단 혹은 두 계단씩 오를 수 있다.
2. 연속으로 세 개의 계단을 모두 밟을 수 없다, 시작점은 포함 X
3. 마지막 계단은 반드시 밟아야 한다, 넘어가기 없음

---

## 먼저 이 문제는

이 문제는 dp방식의 풀이가 가능한 문제이다.  
DP(Dynamic Programming) = 동적 프로그래밍 = 큰 문제를 작은 문제로 나누어 푸는 것, 한번 계산한 문제는 다시 계산하지 않도록 하는 것

### 문제의 포인트

이 문제를 풀 때 중점으로 생각하면 좋을 것 같다고 생각되는 점은

1. 총 계단이 몇 개가 되었든 마지막 계단은 반드시 밟을 것
2. 계단을 연속으로 3개 밟을 수 없다, 연속으로 올라갈 수 있는 계단의 수는 2개이다.

이 두가지만 생각하면 생각보다 쉽게 풀 수 있다.

---

## 풀이

### 의사코드

먼저 간단하게 생각하며 의사코드로 작성해보자

쉽게 생각하기 위해 모든 계단의 점수는 해당 번호에 따라 변동으로 주어지는 것으로 생각한다.  
ex\_ 1번 = 10, 2번 = 20, 3번 = 30, ...

가정 :

1. 계단이 1개일 때 :
   - 계단이 1개일 때 마지막 계단은 1번 이다.
   - 따라서 올라가야될 계단은 1이고, 점수는 10이다.
     - => ○(퐁)
2. 계단이 2개일 때 :
   - 계단이 2개일 때 마지막 계단은 2번 이다.
   - 올라갈 수 있는 계단의 수는 총 2개이다.
   - 연속으로 올라갈 수 있는 계단의 수는 최대 2개이다.
   - 2개를 밟아야 마지막 계단으로 올라가고, 2개를 밟을 수 있으니 모두 밟는다.
   - 따라서 점수는 10 + 20 = 30이다.
     - => ○○(퐁퐁)
3. 계단이 3개일 때 :
   - 계단이 3개일 때 마지막 계단은 3번 이다.
   - 올라갈 수 있는 계단의 수는 총 3개이다.
   - 연속으로 올라갈 수 있는 계단의 수는 최대 2개이다.
   - ! 선택의 갈림길이 생기기 시작한다.
   - 선택권은 두 가지로 생각할 수 있다.
   - 1. 1번을 밟고 3번으로 오르는 루트
     - => ○●○(퐁당퐁)
   - 2. 2번을 밟고 4번으로 오르는 루트
     - => ○●○(퐁당퐁)
   - 위 두가지 루트 중 점수가 더 높은 루트를 선택지로 한다.
     - 1. 10 + 30 = 40
     - 2. 20 + 30 = 50
   - 따라서 점수는 50이다.
4. 계단이 n개일 때 :
   - 계단이 4개 이상부터는 위의 상황처럼 반드시 선택의 갈림길이 생긴다.
   - 마지막 계단이 4번 이라면 선택지는 위처럼 두가지로 생각할 수 있다.
   - 1. 1번을 밟고 3번을 밟고 4번 밟기
     - => 연속으로 2개 이상 밟을 수 없는 상황에서 4번을 밟기 위해서
       1번을 밟고 2번은 건너뛴 뒤 3번과 4번(마지막)을 밟는 것
   - 2. 2번을 밟고 4번 밟기
     - => 연속으로 밟지 않고 한번씩 밟고 오기
   - 위 내용을 수식으로 생각하면 다음과 같다.
   - 1. (n-3) + (n-1) + n
     - => ○●○○(퐁당퐁퐁)
   - 2. (n - 2) + n
     - => ○●○(퐁당퐁)
   - 위의 선택지 중에 합산이 높은 쪽의 값으로 올라간다.

### JavaScript, NodeJs 풀이

```javascript
const BAEAKJOONFILE = "/dev/stdin";
const VSCODEFILE = "./coding/example.txt";

const fs = require("fs");
let [step, ...input] = fs
  .readFileSync(VSCODEFILE)
  .toString()
  .trim()
  .split("\n");

step = Number(step); // 6이라 가정
input = input.map((x) => +x); // 10, 20, 15, 25, 10, 20 이라 가정

const answer = (step, input) => {
  const dp = Array(input.length).fill(0); // dp라는 길이 6개의 배열을 만들고 모두 0으로 초기화
  dp[0] = input[0]; // 계단이 1개일 때
  dp[1] = input[0] + input[1]; // 계단이 2개일 때
  dp[2] = Math.max(input[0], input[1]) + input[2]; // 계단이 3개일 때 두 선택지 중 최대 값

  // 계단이 4개 이상일 때
  for (let i = 3; i < input.length; i += 1) {
    // 계단이 4개 이상을 때 두가지 선택지 중 최대 값
    // dp[i]의 경우 이미 계산된(합연산된) 결과 값
    // input[i]의 경우 input으로 받은 값 그대로인 점을 유의
    dp[i] = Math.max(dp[i - 2] + input[i], dp[i - 3] + input[i - 1] + input[i]);
  }

  console.log(dp[step - 1]);
};

answer(step, input);
```

### 추가로

계단이 n개일 때

- 1. dp[n] = dp(n-3) + input(n-1) + n
- 2. dp[n] = dp(n - 2) + n

이 두가지 선택권 중 1번과 2번의 연산이 다른 것을 볼 수 있다.

n을 7이라고 가정했을 때,  
1번의 경우 2번 연속으로 계단을 오를 수 없기 때문에 7번(n) + 6번(n-1) + 4번(n-3)으로,  
2번의 경우 7번(n) + 5번(n-2)으로 가정한다고 했을 때 1번처럼 그 이전 값인 n-3 혹은 n-4까지
계산하지 않는 이유는 이 로직을 반복하면서 이미 계산된 값이 5번(n-2) 값에 반영이 되어 있는 상태이기 때문이다.

---

[백준]: https://www.acmicpc.net/problem/2579
