---
title: 사이드 이펙트(side effect)
date: 2023-08-14
description: 리액트에서 사이드 이펙트가 어떤 것을 말하는지 알아보자
img: /postImg/study/sideEffect.svg
tag: study
note: react
copyright: https://kr.freepik.com/free-vector/choose-concept-illustration_5784490.htm#query=%EC%98%88%EC%B8%A1&position=4&from_view=search&track=sph
---

## 리액트 그리고 사이드 이펙트

### 먼저 짚고가자

1. 우리 리액트는

사이드 이펙트에 들어가기 앞서 리액트가 어떤 친구인지 되짚어 생각해보자

우리가 리액트를 왜 사용할까, 우리가 사용하는 리액트느 어떤 일을 하는 친구인가

리액트는 UI를 렌더링한다.
사용자가 특정한 행동을 했을 때(입력 등) 그에 맞게 UI를 다시 그리는 등의 UI 렌더링을 하는 것이
리액트의 주요 임무이다.

이런 리액트를 사용할 때 우리는 컴포넌트 단위로 리액트를 사용하는 것에 집중한다.
그 이유는 여러 이유가 있을 수 있지만 보통 주된 이유로 재사용이나 유지 보수의 용이성 등을 뽑으며,
컴포넌트 사용을 적극 추천한다.

그리고 리액트의 컴포넌트는 대부분 순수 함수로 만들어진다.

2. 순수 함수

리액트의 컴포넌트가 함수 형태인 것은 리액트를 한번 써봤다면 알 수 있다.
(물론 클래스형 컴포넌트도 존재하지만 함수형 컴포넌트가 쓰기 쉽고 찾아 보기 쉬운 편일 것이다.)
그런데 순수 함수라는 것은 어떤 것을 뜻하는 것일까?

순수함수는 이름 그대로라고 생각하면 간단하다.

- 함수에 동일한 입력 값을 전달한다면 반환되는 값은 언제나 동일하다 => 인자 값이 같으면 리턴 값이 같다.
- side effect가 없다. => 상세한 내용을 뒤에 다루고 지금은 외부 값(상태)를 변경하는 일이 없다. 정도로 생각하자

말 그대로 순수한 함수, 바깥 놈들(side effects)에게 물들지 않은 순수한 아이이다.
이것을 보면 우리가 사용하는 컴포넌트의 대부분이 왜 순수 함수라는 것인지 생각하기 쉽다.

```javascript
const ProfileCard = ({ name, age }) => {
  return (
    <>
      <h1>{name}</h1>
      <h3>{age}</h3>
    </>
  );
};
```

위의 코드와 같은 컴포넌트가 있다고 했을 때 같은 인자 값을 넣으면 언제나 같은 반환 값이 반환된다.
이런 순수 함수는 우리가 결과를 예측할 수 있기에 프로그램 동작 흐름을 보고 테스트 하거나 이해하기 쉽다.

그럼 이제 본격적으로 이 글의 요점인 사이드 이펙트에 대해 알아보자

---

## 사이드 이펙트(side effect)

### 누구신가요?

우선 사이드 이펙트의 사전적 의미부터 알아보자
다음은 구글에서 사이드 이펙트를 검색했을 때 위키백과 나온 부작용(컴퓨터 과학)이라는 검색 결과의 문서에서
일부 발췌한 내용이다.

> 컴퓨터 과학에서 함수가 결과값 이외에 다른 상태를 변경시킬 때 부작용이 있다고 말한다. 예를 들어, 함수가
> 전역변수나 정적변수를 수정하거나, 인자로 넘어온 것들 중 하나를 변경하거나 화면이나 파일에 데이터를 쓰거나,
> 다른 부작용이 있는 함수에서 데이터를 읽어오는 경우가 있다. 부작용은 프로그램의 동작을 이해하기 어렵게 한다.

간단히 생각해보면 사이드 이펙트는 순수 함수와 반대편에 앉아 있는 친구라고 볼 수 있을 것 같다.

- 함수 내에 동일한 입력에 대해 같은 결과를 보장할 수 없는 것.
- 함수 실행 중 외부의 값을 변경하는 것 이라 볼 수 있겠다.

다음으로 사람들이 말하는 리액트의 사이드 이펙트가 어떤 것이 있는지 살펴보자

1. http 리퀘스트(서버와 api로 데이터 요청)
2. 로컬 스토리지에 데이터 저장
3. 브라우저 api와 상호작용
4. setTimeout, setInterval 등의 타이밍 함수 사용

어... 꽤 많다. 위의 작업들을 사용하지 않고 웹(앱)을 만드는 경우가 있을까? 싶을 정도로 평소에 자주 쓰이는
친구들이라 말할 수 있겠다.

위의 작업들을 보면

1. 데이터 요청
2. 브라우저에 데이터 저장
3. 상호작용으로 인해 복합 이벤트 적용
4. 시간 개념을 이용해 동작 흐름 제어 혹은 값 변경

와 같이 값을 요청하거나 저장, 흐름제어, 변경 등 함수 내에서 실행 된다면 순수 함수 때와 달리 인자 값이 동일해도 결과 값이
일정하지 않을 수 있다. 그렇기에 예측이 힘들고 프로그램 동작 흐름을 파악하기 어렵게 될 수 있다.
이런 작업들을 우리는 사이드 이펙트라 부르고 있다.

그런데 궁금한 것이 있다. 리액트는 사용자와 상호작용을 통해 UI를 변경 시키는 경우가 많다.
http 리퀘스트를 통해 서버에 요청을 보내고 응답으로 받은 데이터를 이용해 화면에 값을 업데이트하는,
이런 경우 본래 리액트가 하는 일 아닌가? 싶다. 근데 왜 http 리퀘스트가 사이드 이펙트라고 불리게 될까?

### 리액트의 본업

이점을 위해 우리는 이 포스팅의 시작부터 리액트의 주요 임무가 무엇인지 살펴 본 것이다.

리액트는 UI를 그리는 친구다. 그렇기에 서버에서 새롭게 데이터를 받고 바뀐 부분이 있다면 UI를 업데이트 해주는 것 또한
리액트의 임무이다.

하지만 사이드 이펙트를 두고 봤을 때 서버와 통신하는 http 리퀘스트와 화면을 그리는 것은 별도로 생각해야 한다.

화면을 그리는 것은 분면 리액트의 임무이기는 하지만 http 리퀘스트는 리액트가 해야할 일이 아니다.
리액트의 주요 임무는 UI를 렌더링하는 것.

리액트는 그리을 기가 막히게 잘 그리는 친구라 우리는 리액트에게 "너는 그림만 신경써줘"라고 말하고 부탁해야지,
그외의 일까지 모든 것을 리액트에게 "너 그림 그리는데 필요한 자료까지 빠짐없이 잘 받아와야 해!"하고 그리기 외의 작업에
신경 쓰이게 하면 안된다는 뜻이다.

즉, 서버에서 데이터를 받아 화면을 그리는 것은  
서버에서 데이터를 받아 / 화면을 그리는 것, 으로 나뉘게 된다. 그렇기에

1. [서버에서 데이터를 받아] 는 별도의 외부 작업(side effect)
2. [화면을 그리는 것] 은 리액트의 임무이다.

명심하자 우리 리액트는 그림 그리는 친구다.

### 약간은 까다로운 친구

이런 사이드 이펙트는 개발 시 자주 보게되는 친구지만 순수함수와 달리 언제나 같은 값을 반화하지 않기에
예측이 어렵고 프로그램의 동작 흐름을 힘들게 할 수 있는 조금은 까다로운 친구이다.
그렇기에 버그를 발생 시킬 수 있다는 점과 함수 실행 시 무한 루프에 빠질 수 있다는 점이 있어
사이드 이펙트를 사용할 때 잘 사용하는 것이 중요하다고 볼 수 있다.

그렇다 아무튼 잘 사용하자.
어떻게?

---

## useEffect 사용

그런 고민을 해결해주기 위해 우리 리액트는 친절하게 useEffect라는 hook을 제공해준다.

useEffect는 다음과 같은 구조를 지닌다.

```javascript
useEffect(() => {...}, [dependencies]);
```

useEffect를 사용하기 위해서는 두개의 인수를 사용한다.

1. 함수
2. 종속성 배열

하나씩 살펴보면,

1. 함수는 컴포넌트가 렌더링을 마친 후 호출된다(리액트가 그림 다 그림). 따라서 여러 사이드 이펙트를 일으키는 코드를 작성해도 괜찮다.
2. 종속성 배열은 사이드 이펙트가 의존하는 값을 배열 형태로 지정한다. 내가 어떤 값이 변경 되었을 때 사이드 이펙트를
   일으키고 싶다하면 그 어떤 값을 배열에 넣어주면 된다.

마지막으로 useEffect 예시를 한번 보고 마무리 한다.

```javascript
import { useEffect, useState } from "react";

const ProfileCard = ({ name, age }) => {
  const [user, setUser] = useState({ name: name, age: age });
  // const [user, setUser] = useState({name, age}); 위와 동일 코드

  useEffect(() => {
    setUser((prev) => ({ ...prev, name: name, age: age }));
    // setUser((prev) => ({...prev, name, age})); 위와 동일 코드
  }, [name, age]);

  return (
    <>
      <h1>{user.name}</h1>
      <h3>{user.age}</h3>
    </>
  );
};
```

1. useState로 user라는 name과 age라는 값을 지닌 객체를 만든다.
2. useEffect를 통해 props로 전달 받은 name과 age의 값이 변경될 때마다 값을 업데이트 한다.
3. 리액트가 사용하는 user.name과 age의 값은 useEffect의 dependencies로 지정한 name과 age의 값이 바뀌는 경우 즉, 내가 설정한 경우에만 변경된다.

위의 코드는 useEffect의 dependencies 사용 방법의 이해를 돕기 위한 코드일뿐, 실제 프로젝트에서 위와 같이 사용하는
경우는 아마 없을 것 같다.

---

이 포스팅을 만들며 참조한 사이트 목록

- [wikipedia][wikipedia]
- [블로그 lasbe][lasbe]
- [블로그 choar816][choar816]

[wikipedia]: https://ko.wikipedia.org/wiki/%EB%B6%80%EC%9E%91%EC%9A%A9_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)
[lasbe]: https://lasbe.tistory.com/164
[choar816]: https://choar816.tistory.com/163
